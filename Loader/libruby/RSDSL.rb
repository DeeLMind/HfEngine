#encoding : utf-8
=begin
  Ruby Shader Domain Special Language.
    by sxysxy
  Generate hlsl from ruby.
=end

module RSDSL
  VERSION = "v 0.01"
  class GenerateError < Exception
  end
  
  class Generator
    def initialize
      @codes = ["//Generated by RSDSL\n"]
      @status = :global 
      @retract = 0;
      @retract_disable = 0;
    end
    def get_code
      return @codes.join
    end
    def retract_add
      @retract += 2
    end
    def retract_sub
      @retract -= 2
    end
    def retract
      if @retract < 0 
        raise GenerateError, "Got invalid retract format."
        return ""
      elsif @retract == 0 || !retractable
        return ""
      else
        return " " * @retract
      end
    end
    def retractable
      return @retract_disable == 0
    end
    def retract_disable
      @retract_disable += 1
    end
    def retract_enable
      @retract_disable -= 1
    end
    def newline
      plain "\n"
    end
    
    #add hlsl code directly
    def plain s
      @codes.push s
    end
    def p s
      plain s.to_s
    end
    def plain_value(a)
      if a.is_a?(String) || a.is_a?(Symbol)
        p a
      elsif a.is_a?(Proc) 
        instance_exec &a
      elsif a.is_a?(Numeric)
        p a
      else
        raise GenerateError, "Unkown value type to plain"
      end
    end
    
    #define a struct
    #struct(name) { }
    def struct(name, &gen)
      s = @status
      @status = :struct
      plain "struct #{name.to_s} {\n"
      begin
        retract_add
        self.instance_exec(&gen)
        retract_sub
      rescue Exception => e
        raise GenerateError, "struct #{name} : #{e.message}"
      end
      plain "}; \n"
      @status = s
    end
    
    #declare a variable in struct/cbuffer/etc
    #declare(name, type, [description])
    def declare(*args)
      if(args.size < 2)
        raise ArgumentError, "Generator#declare requires at least 2 argumengs."
      end
      plain retract
      plain "#{args[1].to_s} #{args[0].to_s}"
      if args[2]
        plain " : #{args[2].to_s}"
      end
      plain ";"
      yield if block_given?
      newline
    end

    #define a variable in a function
    def dvar(name, type, v = nil, &b)
      if @status == :struct 
        raise GenerateError, "Can not define a variable in a struct/cbuffer/etc"
      end
      if v && b
        raise ArgumentError, "Can not set a variable from two values, you should not call dvar/svar with a inital value with a block"
      end
      plain retract
      plain "#{type.to_s} #{name.to_s}"
      if b
        plain " = "
        begin
          instance_exec &b if b
          plain_value v if v
        rescue Exception => e
          raise GenerateError, "dvar #{name} : #{e.message}"
        end
      end
      plain "; \n"
    end
    
    #define an variable getting value from a register.
    def drvar(name, type, *args)
      if(args.size < 1 || args.size > 2)
        raise ArgumentError, "drvar: Wrong number of arguments, expecting (3..4) but got #{args.size}"
      end
      plain retract
      x = nil
      if args.size == 1
        x = args[0]
      else
        x = args[0].to_s + args[1].to_s
      end
      plain "#{type.to_s} #{name.to_s} : register(#{x}); \n"
    end

    #set a value of an variable
    def svar(name, v = nil, &b)
      if @status == :struct 
        raise GenerateError, "Can not set a variable in a struct/cbuffer/etc"
      end
      if v && b
        raise ArgumentError, "Can not set a variable from two values, you should not call dvar/svar with a inital value with a block"
      end
      plain retract
      plain "#{name.to_s}"
      if b
        plain " = "
        begin
          plain_value v if v
          instance_exec &b if b
        rescue Exception => e
          raise GenerateError, "svar #{name} : #{e.message}"
        end
      else
        raise GenerateError, "svar: no right value"
      end
      plain "; \n" if retractable
    end
    
    #refer an variable by name
    def var(name)
      plain name.to_s
    end

    #SamplerState
    define_method(:SamplerState) do |name, slot|
      drvar name, "SamplerState", 's', slot
    end
      
    #Texture2D
    define_method(:Texture2D) do |name, slot|
      drvar name, "Texture2D", 't', slot
    end

    #if
    def cif(con, c1, c2)
      plain retract
      plain "if("
      plain_value(con)
      plain ") {\n"
      retract_add
      begin
        instance_exec(&c1)
        retract_sub
        plain retract
        plain "}"
        if c2
          plain " else { \n"
          retract_add
          instance_exec(&c2)
          retract_sub
          plain retract
          plain "}"
        end
      rescue Exception => e
        raise GenerateError, "cif:insga #{e.message}"
      end
      newline
    end
 
    #while
    def cwhile(con, &b)
      plain retract
      plain "while("
      plain_value(con)
      plain ") {\n"
      retract_add
      instance_exec(&b)
      retract_sub
      plain retract
      plain "} \n"
    end
    
    #return 
    def creturn(&b)
      plain retract
      plain "return "
      retract_disable
      instance_exec &b if b
      retract_enable
      plain "; \n"
    end
    
    #declare a constant buffer.
    def cbuffer(name, slot, &gen)
      s = @status
      @status = :struct
      plain "cbuffer #{name.to_s} : register(b#{slot}) { \n"
      begin
        retract_add
        self.instance_exec(&gen)
        retract_sub
      rescue Exception => e
        raise GenerateError, "cbuffer #{name} : #{e.message}"
      end
      plain "}; \n"
      @status = s
    end

    #call function
    def call(name, *args)
      plain retract
      plain "#{name.to_s}("
      flag = false
      retract_disable
      args.each {|a|
        plain ", " if flag
        plain_value a
        flag = true 
      }
      retract_enable
      plain ")"
      plain "; \n" if retractable
    end
    
    #call member function
    def obj_call(obj_name, fname, *arg)
      call("#{obj_name}.#{fname}", *arg)
    end
    
    #define function
    #defunc(name, return_type, *args) {...}
    #args : should be some arrays descibe the arguments of the function. (the same format as 'declare'
    #the last element of args can be a Symbol(String) which tells the desciption of the function.
=begin
    example:
    defunc(:f, :float4, [:pos, :float3, :POSITION], [:color, :float4], :SV_TARGET) {...}
    generates:
    float4 f(float3 pos : POSITION, float4 color) : SV_TARGET {
      ...
    }
=end
    def defunc(name, ret, *args, &gen)
      plain "#{ret.to_s} #{name.to_s}("
      args_status = :unknown
      
      args.each {|a|
        if a.is_a?(Array)
          if a.size < 2 
            raise GenerateError, "defunc: declare an argument requires at least 2 notes(name and type)."
          end
          if args_status != :unknown && args_status != :parse_args
            raise GenerateError, "defunc:you should declare arguments before a function description."
          end
          if args_status == :parse_args
            plain ", "
          end
          args_status = :parse_args
          plain "#{a[1].to_s} #{a[0].to_s}"
          if a.size >= 3
            plain " : #{a[2].to_s}"
          end
        elsif a.is_a?(String) || a.is_a?(Symbol)
          args_status = :parse_description
          plain ") : #{a.to_s} { \n"
        else 
          raise GenerateError, "defunc: Unknown argument"
        end
      }
      if args_status != :parse_description
        plain ") { \n"
      end
      begin
        retract_add
        self.instance_exec(&gen)      
        retract_sub
      rescue Exception => e
        raise GenerateError, "defunc : #{name.to_s}, #{e.message}"
      end
      plain "} \n"
    end
    
    #comment 
    def comment(c)
      plain "/* #{c} */"
    end
    
    #C language features.
    #c include
    def inc(f)
      plain "#include <#{f.to_s}> \n"
    end
    #get address
    def addr(v)
      plain "&#{v}"
    end
  end

  def self.generate(&gen)
    g = Generator.new
    g.instance_exec(&gen)
    return g.get_code
  end
end

print RSDSL.generate {
  struct(:vs_output) {
    declare(:pos,:float4,:SV_POSITION) {
      comment "Position of the vertex"
    }
    declare :color, :float4, :COLOR
  }
  cbuffer(:param, 0) {
    declare(:rate, :float)
  }
  Texture2D(:texture, 0)
  SamplerState(:sampler, 0)
  newline
  defunc(:aplusb, :float, [:a, :float], [:b, :float]) {
    dvar(:c, :float) { p "a + b" }
    creturn { var :c }
  }
  defunc(:error, :float, [:a, :float], [:b, :float]) {
    cwhile(0) {
      creturn {
        call :aplusb, :a, proc {call :aplusb, :b, 233.0}
      }
    }
    cif("a >= b", 
        proc { creturn { p "a - b" }}, 
        proc { creturn { p "b - a" }})
  }
  defunc(:main, :float4, [:data, :vs_output], :SV_TARGET) {
    dvar(:r, :float4)
    svar(:r) { var "data.color" }
    creturn {var :r}
  }
}

=begin
print RSDSL.generate {
  inc "stdio.h"
  defunc(:main, :int) {
    dvar :a, :int
    dvar :b, :int
    call(:scanf, proc {addr :a}, proc {addr :b})
    call(:printf, '"%d\\n"', "a + b")
  }
}
=end